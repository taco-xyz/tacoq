from typing import Any, Optional
from uuid import UUID
from enum import Enum
from datetime import datetime
import uuid
import re
from pydantic import BaseModel, Field


TaskInput = Any
""" Task input data defined by the user - they can use whatever format they want, but
they must handle the serialization and deserialization of the data themselves. """

TaskOutput = Any
""" Task output data defined by the user - they can use whatever format they want, but
they must handle the serialization and deserialization of the data themselves. """


class TaskStatus(str, Enum):
    """The status of a task"""

    PENDING = "pending"
    """ The task is created but not yet assigned """

    RUNNING = "running"
    """ The task is being processed by a worker """

    COMPLETED = "completed"
    """ The task has completed successfully """


class TaskKind(BaseModel):
    """A type of task. Requires both the type of worker that executes it and the name of the task."""

    worker_kind: str
    """ The kind of worker that executes the task. """

    name: str
    """ The name of the task. """

    def __str__(self) -> str:
        return f"{self.worker_kind}:{self.name}"

    @staticmethod
    def from_str(task_str: str) -> "TaskKind":
        """Create a TaskKind from a string.

        Format: `worker_kind:task_name`

        ### Arguments
        - `task_str`: The string to create the TaskKind from.

        ### Returns
        - `TaskKind`: The TaskKind created from the string.

        ### Example
        - `"worker_kind:task_name"` -> `TaskKind(worker_kind="worker_kind", name="task_name")`
        """

        # Check if the format is correct - there must be one and only one colon. Check using Regex
        if not re.match(r"^[a-zA-Z0-9_-]+:[a-zA-Z0-9_-]+$", task_str):
            raise ValueError(
                "Task kind must be in the format of `worker_kind:task_name`"
            )

        worker_kind, name = task_str.split(":")
        return TaskKind(worker_kind=worker_kind, name=name)


class TaskResult(BaseModel):
    """Task results contain the output or error data from a completed task."""

    data: TaskOutput
    """ The data of the task's result. """

    is_error: bool
    """ Whether the task failed. """

    started_at: datetime
    """ The time the task was started. """

    completed_at: datetime
    """ The time the task was completed. """


class Task(BaseModel):
    """Tasks are sent to workers to be executed with a specific payload.
    Workers are eligible for receiving certain tasks depending on their
    kind.
    """

    id: UUID = Field(default_factory=uuid.uuid4)
    """The unique ID of the task. Generated by the client so that it can be communicated to the
    manager and the workers directly."""

    task_kind: TaskKind
    """ The kind of the task - dictates the queue that it will be placed in (via the worker kind)
    and dictates how the worker will interpret the task. """

    input_data: TaskInput = Field(default=None)
    """ The input data of the task. """

    status: TaskStatus = Field(default=TaskStatus.PENDING)
    """ The current status of the task at the time of retrieval."""

    created_at: datetime = Field(default_factory=datetime.now)
    """ The time the task was created. """

    result: Optional[TaskResult] = Field(default=None)
    """ The result of the task. """

    priority: int = Field(default=0)
    """ The priority of the task. """

    @property
    def has_finished(self) -> bool:
        """Whether the task has finished."""

        return self.status == TaskStatus.COMPLETED


class WorkerKindBrokerInfo(BaseModel):
    """Information about a worker kind."""

    queue_name: str
    """The name of the queue for this worker kind. The worker will use this information to connect to the correct queue."""

    routing_key: str
    """The routing key for this worker kind. The worker will use this information to route the task to the correct worker."""

    worker_kind: str
    """The kind of worker."""
