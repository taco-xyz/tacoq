"""Types for the task model.

This model is very sensible because serialization logic must be consistent
across all other languages and the core service. `TaskInput` and `TaskOutput`
are strings and are expected to be serialized and deserialized by the user."""

import uuid
from datetime import datetime, timedelta
from enum import Enum
from typing import Optional, Self
from uuid import UUID

from pydantic import Field
from tacoq.core.encoding.models import Decoder
from tacoq.core.models.avro_serializable_base_model import (
    AvroSerializableBaseModel,
    avro_schema_path,
)
from typing_extensions import TypeVar

# Types ================================

TaskRawInput = bytes
""" Task input data defined by the user - they can use whatever format they 
want, but they must handle the serialization and deserialization of the data
themselves."""

TaskRawOutput = bytes
""" Task output data defined by the user - they can use whatever format they
want, but they must handle the serialization and deserialization of the data 
themselves. """


class TaskStatus(str, Enum):
    """The current status of a task."""

    PENDING = "pending"
    """ The task is created but hasn't yet been received by a worker. """

    PROCESSING = "processing"
    """ The task is being processed by a worker. """

    COMPLETED = "completed"
    """ The task has completed. This does not imply the task was successful. """


DecodedData = TypeVar("DecodedData")


@avro_schema_path("schemas/avro/task.json")
class Task(AvroSerializableBaseModel):
    """Task to be executed by a worker.

    For simplicity's sake, task objects carry the entire payload of the task, from
    the input data to the output data. You can consult `has_finished` and `status`
    to determine the state of the task.

    ### Attributes:
    - id: The unique ID of the task.
    - task_kind: The kind of the task - dictates which function the worker will execute
    to handle it.
    - worker_kind: The kind of worker that will execute the task. Dictates the queue that
    the task will be routed through.
    - created_at: The time the task was created at.
    - started_at: The time the task was started at.
    - completed_at: The time the task was completed at.
    - input_data: The input data of the task.
    - output_data: The data output by the task.
    - is_error: Whether the task failed. Used primarly for the dead letter queue.
    - status: The current status of the task at the time of retrieval. See `TaskStatus` for more details.
    - priority: The priority of the task, ranging from 0 (lowest) to 255 (highest). For best practices on using the priority, see RabbitMQ's.
    - ttl_duration: An optional determining for how long a task should stay alive after it has been completed.
    - otel_ctx_carrier: The OpenTelemetry context carrier for the task.

    ### Usage:
    Tasks are not meant to be instantiated by the user. They are instead
    created and retrieved using the `PublisherClient`.
    """

    id: UUID = Field(default_factory=uuid.uuid4)
    """The unique ID of the task. Generated by the client so that it can be 
    communicated to the relay and the workers directly."""

    task_kind: Optional[str] = Field(default=None)
    """ The kind of the task - dictates which function the worker will execute 
    to handle it."""

    worker_kind: Optional[str] = Field(default=None)
    """ The kind of worker that will execute the task. Dictates the queue that 
    the task will be routed through. """

    # Timestamps

    created_at: datetime = Field(default_factory=lambda: datetime.now())
    """ The time the task was created at. """

    started_at: Optional[datetime] = Field(default=None)
    """ The time the task was started at. """

    completed_at: Optional[datetime] = Field(default=None)
    """ The time the task was completed at. """

    updated_at: datetime = Field(default_factory=lambda: datetime.now())
    """ The last time the task object was updated in the database. """

    # Data

    executed_by: Optional[str] = Field(default=None)
    """ The name of the worker that executed the task. """

    input_data: Optional[TaskRawInput] = Field(default=None)
    """ The raw input data of the task. To decode it, use the `get_decoded_input_data` method. """

    output_data: Optional[TaskRawOutput] = Field(default=None)
    """ The raw output data of the task. To decode it, use the `get_decoded_output_data` method. """

    is_error: Optional[int] = Field(default=None)
    """ Whether the task failed. Used primarly for the dead letter queue."""

    # Metadata

    priority: Optional[int] = Field(default=None)
    """ The priority of the task, ranging from 0 (lowest) to 255 (highest). 
    For best practices on using the priority, see RabbitMQ's 
    [Priority Queues](https://www.rabbitmq.com/priority.html).
    """

    ttl_duration: Optional[int] = Field(default=None)
    """ The duration of how long the task should live after it has been completed"""

    # Telemetry

    otel_ctx_carrier: Optional[dict[str, str]] = Field(default=None)
    """ The OpenTelemetry context carrier for the task. """

    @property
    def status(self: Self) -> TaskStatus:
        """The current status of the task at the time of retrieval.

        ### Returns:
        The current status of the task at the time of retrieval.
        """
        if self.completed_at:
            return TaskStatus.COMPLETED
        elif self.started_at:
            return TaskStatus.PROCESSING

        return TaskStatus.PENDING

    @property
    def has_finished(self: Self) -> bool:
        """Whether or not the task has finished executing.

        ### Returns:
        `True` if the task has finished, `False` otherwise.
        """

        return self.completed_at is not None

    @property
    def completion_time(self: Self) -> Optional[timedelta]:
        """The time it took for the task to complete.

        ### Returns:
        The time it took for the task to complete, or `None` if the task has not completed.
        """

        if self.completed_at is None or self.started_at is None:
            return None
        return self.completed_at - self.started_at

    # Decoding the data

    def get_decoded_input_data(
        self: Self, decoder: Decoder[DecodedData]
    ) -> DecodedData:
        """Get the decoded input data of the task.

        ### Arguments:
        - decoder: The decoder to use to decode the input data.

        ### Returns:
        The decoded input data of the task.

        ### Raises:
        - `ValueError` if the input data is not set.

        ### Example:
        ```python
        from tacoq.core.encoding import PydanticDecoder

        decoder = PydanticDecoder(model=MyModel)
        task = await relay.get_task(task_id)
        decoded_data = task.get_decoded_input_data(decoder)
        ```
        """
        if self.input_data is None:
            raise ValueError("Input data is not set but you are trying to decode it")
        return decoder.decode(self.input_data)

    def get_decoded_output_data(
        self: Self, decoder: Decoder[DecodedData]
    ) -> DecodedData:
        """Get the decoded output data of the task.

        ### Arguments:
        - decoder: The decoder to use to decode the output data.

        ### Returns:
        The decoded output data of the task.

        ### Raises:
        - `ValueError` if the output data is not set.

        ### Example:
        ```python
        from tacoq.core.encoding import PydanticDecoder

        decoder = PydanticDecoder(model=MyModel)
        task = await relay.get_task(task_id)
        decoded_data = task.get_decoded_output_data(decoder)
        ```
        """

        if self.output_data is None:
            raise ValueError("Output data is not set but you are trying to decode it")
        return decoder.decode(self.output_data)
